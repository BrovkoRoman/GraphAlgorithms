#include <iostream>
#include <vector>

using namespace std;
const int N = 1e5 + 5; // константа должна быть не меньше количества вершин в графе
// если количество вершин неизвестно, можно использовать vector вместо глобальных массивов

bool used[N]; // для каждой вершины будем хранить, посещена ли она

vector <int> g[N]; // граф будем хранить в виде списка смежности:
// для каждой вершины хранится список всех вершин, в которые из неё есть ребро

void dfs(int v) { // функция обхода из вершины v
    used[v] = true; // отмечаем вершину как посещённую
    cout << "dfs " << v + 1 << endl; // вывод вершины (во вводе/выводе будем нумеровать вершины с 1, а в программе с 0, поэтому +1)

    for(auto to:g[v]) { // перебор всех элементов из g[v] (вершин, в которые из v есть ребро)
        if(!used[to]) {
            dfs(to); // если вершина ещё не посещена, то рекурсивно запускаемся из неё
        }
    }
}

int main() {
    int n, m; // число вершин и рёбер
    cin >> n >> m;

    for(int i = 0; i < m; i++) {
        int u, v; // вводим концы ребра (они должны быть от 1 до n)
        cin >> u >> v;

        u--; // но в программе будем нумеровать вершины от 0 до n-1
        v--;

        g[u].push_back(v);
        g[v].push_back(u); // эта строка нужна только для неориентированных графов
    }

    int start = 0; // стартовая вершина

    dfs(start);
}

/*
Пример входных данных (разобран в прикреплённой лекции):
7 7
1 3
1 4
3 5
4 5
4 7
5 7
2 6

*/
